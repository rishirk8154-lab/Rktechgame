<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RKTechGame | Thread Priorities & Synchronization in Java</title>
<link
  href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700;400&display=swap"
  rel="stylesheet"
/>
<style>
  :root {
    --kakashi-blue: #546285;
    --kakashi-gray: #cfd2dc;
    --kakashi-dark: #292a36;
    --kakashi-red: #db1d29;
    --kakashi-shadow: #42516f;
    --tagline-color: #000000;
    --tagline-shadow: #444444aa;
    --link-hover: #ff3a3a;
  }
  body {
    margin: 0;
    font-family: "Montserrat", Arial, sans-serif;
    background: linear-gradient(120deg, var(--kakashi-blue) 20%, var(--kakashi-gray) 100%);
    color: var(--kakashi-dark);
    padding: 40px 20px;
    min-height: 100vh;
    overflow-x: hidden;
  }
  header {
    text-align: center;
    margin-bottom: 40px;
  }
  header h1 {
    color: var(--kakashi-red);
    font-size: 3rem;
    letter-spacing: 3px;
    font-weight: 900;
    margin: 0;
    text-shadow:
      0 0 8px var(--kakashi-red),
      0 0 14px var(--kakashi-red),
      0 0 24px var(--kakashi-red);
  }
  section {
    max-width: 900px;
    background: #f0f4faee;
    border-radius: 21px;
    padding: 30px 40px;
    margin-bottom: 36px;
    box-shadow: 0 3px 18px #54628533;
    animation: fadeInUp 1.3s cubic-bezier(0.42, 0, 0.58, 1) both;
  }
  h2 {
    color: var(--kakashi-blue);
    font-size: 2.1rem;
    margin-bottom: 16px;
    border-left: 6px solid var(--kakashi-red);
    padding-left: 16px;
  }
  h3 {
    color: var(--kakashi-red);
    margin-top: 22px;
    margin-bottom: 10px;
  }
  p {
    font-size: 1rem;
    color: var(--kakashi-dark);
    margin: 12px 0;
  }
  ul {
    margin-left: 30px;
    margin-top: 10px;
    color: var(--kakashi-dark);
    font-size: 1rem;
  }
  pre {
    background: #dde4f0;
    border-radius: 10px;
    padding: 18px;
    font-family: 'Courier New', Courier, monospace;
    overflow-x: auto;
    font-size: 0.9rem;
    color: #2d3a67;
    margin-top: 10px;
  }
  @keyframes fadeInUp {
    0% {
      transform: translateY(90px);
      opacity: 0;
    }
    80% {
      opacity: 0.6;
    }
    100% {
      transform: translateY(0);
      opacity: 1;
    }
  }
  footer {
    text-align: center;
    margin: 64px 0 36px 0;
    font-size: 1.1rem;
    color: #333a4d88;
    letter-spacing: 1px;
    user-select: none;
  }
  @media (max-width: 770px) {
    body {
      padding: 20px 15px;
    }
    section {
      padding: 20px 25px;
    }
    header h1 {
      font-size: 2.4rem;
      letter-spacing: 2px;
    }
  }
</style>
</head>
<body>
<header>
  <h1>RKTechGame | Thread Priorities & Synchronization in Java</h1>
</header>

<section>
  <h2>Thread Priorities kya hoti hain?</h2>
  <p>
    Java threads ko priority di ja sakti hai, jo thread scheduler ko batati hai ki kaunse thread ko pehle CPU time milna chahiye. Priority number 1 se lekar 10 tak hota hai, jisme 1 sabse lowest aur 10 sabse highest priority hoti hai.
  </p>
  <ul>
    <li>Default priority hoti hai 5 (NORM_PRIORITY)</li>
    <li>Priority set karne ke liye <code>setPriority(int)</code> method use hota hai.</li>
    <li>Thread priority thread scheduling ko influence kar sakta hai, lekin guaranteed nahi hai ki higher priority thread hamesha pehle chalega.</li>
  </ul>
</section>

<section>
  <h2>Thread Priority Example</h2>
  <pre><code>class PriorityDemo extends Thread {
  public PriorityDemo(String name) {
    super(name);
  }
  public void run() {
    System.out.println(getName() + " running with priority " + getPriority());
  }
}
public class ThreadPriorityExample {
  public static void main(String[] args) {
    PriorityDemo t1 = new PriorityDemo("Low Priority Thread");
    PriorityDemo t2 = new PriorityDemo("Max Priority Thread");
    PriorityDemo t3 = new PriorityDemo("Normal Priority Thread");

    t1.setPriority(Thread.MIN_PRIORITY);
    t2.setPriority(Thread.MAX_PRIORITY);
    t3.setPriority(Thread.NORM_PRIORITY);

    t1.start();
    t2.start();
    t3.start();
  }
}</code></pre>
  <p>Output me threads ke naam ke saath unki priority bhi dikhegi.</p>
</section>

<section>
  <h2>Thread Synchronization kya hai?</h2>
  <p>
    Synchronization ka matlab hai ki jab multiple threads ek shared resource ya critical section ko access karte hain, toh code ko is tarah se likhna jisse data corruption ya inconsistency na ho. 
  </p>
  <ul>
    <li>Java me <code>synchronized</code> keyword diya gaya hai, jise method ya block dono me use kar sakte hain.</li>
    <li>Jab ek thread synchronized block/method chalata hai, doosre threads ko ussi resource ke synchronized section ko wait karna padta hai.</li>
    <li>Isse race condition, deadlock jaise problems se bachav hota hai.</li>
  </ul>
</section>

<section>
  <h2>Synchronization Example (Method level)</h2>
  <pre><code>class Counter {
  private int count = 0;
  public synchronized void increment() {
    count++;
    System.out.println(Thread.currentThread().getName() + " count: " + count);
  }
  public int getCount() {
    return count;
  }
}
public class SyncExample {
  public static void main(String[] args) {
    Counter counter = new Counter();

    Runnable task = () -> {
      for (int i = 0; i < 5; i++) {
        counter.increment();
        try {
          Thread.sleep(100);
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
      }
    };

    Thread t1 = new Thread(task, "Thread-1");
    Thread t2 = new Thread(task, "Thread-2");

    t1.start();
    t2.start();
  }
}</code></pre>
  <p>Count incrementation sequence properly synchronized hoti hai, race condition nahi hoti.</p>
</section>

<section>
  <h2>Synchronization Block Example</h2>
  <pre><code>class SyncBlockExample {
  private int count = 0;
  public void increment() {
    synchronized(this) {
      count++;
      System.out.println(Thread.currentThread().getName() + " synchronized count: " + count);
    }
  }
}
public class SyncBlockDemo {
  public static void main(String[] args) {
    SyncBlockExample example = new SyncBlockExample();

    Runnable task = () -> {
      for (int i = 0; i < 5; i++) {
        example.increment();
        try {
          Thread.sleep(100);
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
      }
    };

    Thread t1 = new Thread(task, "Thread-A");
    Thread t2 = new Thread(task, "Thread-B");

    t1.start();
    t2.start();
  }
}</code></pre>
  <p>Synchronized block ke andar ka code ek waqt mein sirf ek thread chala sakta hai.</p>
</section>

<footer>
  <b>&copy; 2025 RKTechGame | All rights reserved</b>
</footer>
</body>
</html>
