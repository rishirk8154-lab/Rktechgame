<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Segment Trees & Fenwick Trees | Data Structures & Algorithms | RKTechGame</title>
  <meta name="description" content="Learn about Segment Trees and Fenwick Trees (Binary Indexed Trees), their uses, construction, update and query operations with detailed Python examples." />
  <link rel="canonical" href="https://rktechgame.fun/dsa-segment-fenwick-trees.html" />
  <style>
    body {
      background-color: #101820;
      color: #e1e1e1;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 2rem 3rem;
      line-height: 1.7;
      min-height: 100vh;
    }
    h1, h2, h3 {
      color: #f05454;
      margin-bottom: 0.6rem;
    }
    h1 {
      font-size: 2.5rem;
      font-weight: 700;
      text-align: center;
      margin-top: 0;
      margin-bottom: 1.5rem;
    }
    h2 {
      font-size: 2rem;
      margin-top: 1.5rem;
    }
    h3 {
      font-size: 1.4rem;
      margin-top: 1.2rem;
      margin-bottom: 0.5rem;
    }
    p, pre, ul {
      max-width: 900px;
      margin: 0 auto 2rem auto;
      font-size: 1.15rem;
      color: #ddd;
    }
    ul {
      list-style-type: square;
      padding-left: 1.5rem;
    }
    ul li {
      margin-bottom: 0.8rem;
    }
    pre {
      background: #1a273b;
      padding: 15px;
      border-radius: 8px;
      overflow-x: auto;
      font-family: 'Courier New', Courier, monospace;
      color: #f05454;
    }
    footer {
      text-align: center;
      margin-top: 3.5rem;
      padding-top: 1rem;
      border-top: 1px solid #f05454;
      color: #888;
      font-size: 0.95rem;
    }
    @media(max-width: 768px) {
      body {
        padding: 1rem 1.2rem;
        line-height: 1.5;
      }
      h1 {
        font-size: 2rem;
      }
      h2 {
        font-size: 1.6rem;
      }
      h3 {
        font-size: 1.2rem;
      }
      p, pre, ul {
        font-size: 1rem;
      }
    }
  </style>
</head>
<body>

<h1>Segment Trees & Fenwick Trees (Binary Indexed Trees)</h1>

<h2>Segment Trees</h2>
<p>Segment Tree is a binary tree used for storing intervals or segments. Each node of the segment tree stores information about a segment of the array.</p>
<p>It supports efficient range queries and updates with O(log n) time complexity.</p>

<h3>Key Operations</h3>
<ul>
  <li><strong>Build:</strong> Construct the tree from the input array recursively.</li>
  <li><strong>Query:</strong> Find the sum/min/max over a range efficiently.</li>
  <li><strong>Update:</strong> Update element values and propagate changes up the tree.</li>
</ul>

<h3>Python Implementation - Range Sum Query & Update</h3>
<pre><code>class SegmentTree:
    def __init__(self, arr):
        self.n = len(arr)
        self.tree = [0] * (4 * self.n)
        self.build(arr, 0, 0, self.n - 1)
    
    def build(self, arr, node, start, end):
        if start == end:
            self.tree[node] = arr[start]
        else:
            mid = (start + end) // 2
            self.build(arr, 2 * node + 1, start, mid)
            self.build(arr, 2 * node + 2, mid + 1, end)
            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]

    def update(self, node, start, end, idx, val):
        if start == end:
            self.tree[node] = val
        else:
            mid = (start + end) // 2
            if idx <= mid:
                self.update(2 * node + 1, start, mid, idx, val)
            else:
                self.update(2 * node + 2, mid + 1, end, idx, val)
            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]

    def query(self, node, start, end, L, R):
        if R < start or L > end:
            return 0
        if L <= start and end <= R:
            return self.tree[node]
        mid = (start + end) // 2
        left_sum = self.query(2 * node + 1, start, mid, L, R)
        right_sum = self.query(2 * node + 2, mid + 1, end, L, R)
        return left_sum + right_sum

# Usage example
arr = [1, 3, 5, 7, 9, 11]
st = SegmentTree(arr)
print("Sum of values in range(1,3):", st.query(0, 0, st.n-1, 1, 3))  # Output: 15
st.update(0, 0, st.n-1, 1, 10)
print("After update sum in range(1,3):", st.query(0, 0, st.n-1, 1, 3))  # Output: 22
</code></pre>

<h2>Fenwick Trees (Binary Indexed Trees)</h2>
<p>Fenwick Tree (or BIT) is a data structure that provides efficient methods for cumulative frequency tables or prefix sums, supporting update and query operations in O(log n) time.</p>

<h3>Key Idea</h3>
<ul>
  <li>Uses binary indexed representation of indices.</li>
  <li>Efficiently accumulates sums for prefixes.</li>
  <li>Smaller and simpler than segment tree for prefix sum problems.</li>
</ul>

<h3>Python Implementation - Prefix Sum & Update</h3>
<pre><code>class FenwickTree:
    def __init__(self, size):
        self.size = size
        self.tree = [0] * (size + 1)

    def update(self, idx, val):
        while idx <= self.size:
            self.tree[idx] += val
            idx += idx & (-idx)

    def query(self, idx):
        res = 0
        while idx > 0:
            res += self.tree[idx]
            idx -= idx & (-idx)
        return res

# Usage example
arr = [1, 3, 5, 7, 9, 11]
ft = FenwickTree(len(arr))
for i, val in enumerate(arr, 1):
    ft.update(i, val)

print("Sum of first 3 elements:", ft.query(3))  # Output: 9 (1+3+5)
ft.update(2, 4)  # Increment value at index 2 by 4
print("After update, sum of first 3 elements:", ft.query(3))  # Output: 13 (1+7+5)
</code></pre>

<footer>&copy; 2025 RKTechGame. All rights reserved.</footer>

</body>
</html>
