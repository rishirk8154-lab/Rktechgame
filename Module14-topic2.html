<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RKTechGame | Common Design Patterns in Java - Detailed</title>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700;400&display=swap" rel="stylesheet" />
<style>
  :root {
    --kakashi-blue: #546285;
    --kakashi-gray: #cfd2dc;
    --kakashi-dark: #292a36;
    --kakashi-red: #db1d29;
    --kakashi-shadow: #42516f;
    --tagline-color: #000000;
    --tagline-shadow: #444444aa;
    --link-hover: #ff3a3a;
  }
  body {
    margin: 0;
    font-family: 'Montserrat', Arial, sans-serif;
    background: linear-gradient(120deg, var(--kakashi-blue) 20%, var(--kakashi-gray) 100%);
    color: var(--kakashi-dark);
    padding: 40px 20px;
    line-height: 1.6;
    min-height: 100vh;
  }
  header {
    text-align: center;
    margin-bottom: 40px;
  }
  header h1 {
    font-size: 3rem;
    letter-spacing: 3px;
    color: var(--kakashi-red);
    font-weight: 900;
    margin: 0;
    text-shadow:
      0 0 8px var(--kakashi-red),
      0 0 14px var(--kakashi-red),
      0 0 24px var(--kakashi-red);
  }
  section {
    max-width: 900px;
    background: #f0f4faee;
    border-radius: 21px;
    padding: 30px 40px;
    margin-bottom: 36px;
    box-shadow: 0 3px 18px #54628533;
    animation: fadeInUp 1.3s cubic-bezier(0.42,0,0.58,1) both;
  }
  h2 {
    font-size: 2.2rem;
    color: var(--kakashi-blue);
    margin-bottom: 16px;
    border-left: 6px solid var(--kakashi-red);
    padding-left: 16px;
  }
  p, ul, pre {
    font-size: 1rem;
    color: var(--kakashi-dark);
    margin: 12px 0;
  }
  ul {
    margin-left: 30px;
  }
  ul li {
    margin-bottom: 12px;
  }
  pre {
    background: #dde4f0;
    padding: 20px;
    border-radius: 10px;
    font-family: 'Courier New', Courier, monospace;
    font-size: 0.95rem;
    overflow-x: auto;
  }
  @keyframes fadeInUp {
    0% {
      opacity: 0;
      transform: translateY(90px);
    }
    80% {
      opacity: 0.6;
    }
    100% {
      opacity: 1;
      transform: translateY(0);
    }
  }
  footer {
    text-align: center;
    margin: 64px 0 36px;
    color: #333a4d88;
    font-size: 1.1rem;
    letter-spacing: 1px;
    user-select: none;
  }
  @media (max-width:768px) {
    body {
      padding: 30px 15px;
    }
    header h1 {
      font-size: 2.5rem;
      letter-spacing: 2px;
    }
    section {
      padding: 25px 20px;
    }
    h2 {
      font-size: 1.8rem;
      padding-left: 12px;
      border-left-width: 4px;
      margin-bottom: 16px;
    }
    p, ul, pre {
      font-size: 0.9rem;
    }
  }
</style>

  
<!-- Google AdSense Auto Ads code added here -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3203979560782674"
    crossorigin="anonymous"></script>
</head>
<body>
<header>
  <h1>RKTechGame | Common Design Patterns in Java - Detailed</h1>
</header>

<section>
  <h2>Singleton Pattern</h2>
  <p>
    Singleton pattern ensure karta hai ki ek class ka sirf ek hi instance create ho aur wo globally accessible ho. Ye pattern specially useful hota hai jab resource intensive objects ko share karna ho, jaise database connection, logging, thread pool.
  </p>
  <p>
    Singleton thread-safe banane ke liye synchronized block ya volatile keyword ka istemal hota hai taaki concurrent environment me multiple instance creation na ho.
  </p>
  <pre><code>public class Singleton {
    private static volatile Singleton instance;
    private Singleton() {
        // private constructor
    }
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized(Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}</code></pre>
</section>

<section>
  <h2>Factory Pattern</h2>
  <p>
    Factory pattern ka use tab hota hai jab class instantiation logic complex ho ya object creation dynamic ho. Factory ek interface ya class provide karta hai jo client ko direct class instantiation ki jagah object deta hai.
  </p>
  <p>
    Factory me naye object create karne ke liye conditions ya configurations ka use hota hai.
  </p>
  <pre><code>// Product Interface
interface Animal {
    void speak();
}

// Concrete Products
class Dog implements Animal {
    public void speak() {
        System.out.println("Dog barks");
    }
}
class Cat implements Animal {
    public void speak() {
        System.out.println("Cat meows");
    }
}

// Factory Class
class AnimalFactory {
    public static Animal createAnimal(String type) {
        if (type.equalsIgnoreCase("dog"))
            return new Dog();
        else if (type.equalsIgnoreCase("cat"))
            return new Cat();
        else
            throw new IllegalArgumentException("Unknown animal");
    }
}

// Client Usage
public class FactoryDemo {
    public static void main(String[] args) {
        Animal animal1 = AnimalFactory.createAnimal("dog");
        animal1.speak();  // Dog barks

        Animal animal2 = AnimalFactory.createAnimal("cat");
        animal2.speak();  // Cat meows
    }
}
</code></pre>
</section>

<section>
  <h2>Observer Pattern</h2>
  <p>
    Observer pattern ek behavioral pattern hai jisme ek object (subject) dusre multiple objects (observers) ko notify karta hai jab uski state change hoti hai. Ye decoupled communication allow karta hai.
  </p>
  <p>
    Is pattern ka use event listener systems, notification framework, ya real-time update ke liye hota hai.
  </p>
  <pre><code>import java.util.ArrayList;
import java.util.List;

// Observer Interface
interface Observer {
    void update(String event);
}

// Subject Class
class Subject {
    private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();
    private String state;

    public void registerObserver(Observer obs) {
        observers.add(obs);
    }
    public void removeObserver(Observer obs) {
        observers.remove(obs);
    }
    public void notifyObservers() {
        for (Observer obs : observers) {
            obs.update(state);
        }
    }
    public void setState(String newState) {
        this.state = newState;
        notifyObservers();
    }
}

// Concrete Observer
class ConcreteObserver implements Observer {
    private String name;
    public ConcreteObserver(String name) {
        this.name = name;
    }
    public void update(String event) {
        System.out.println(name + " received update: " + event);
    }
}

// Demo Usage
public class ObserverDemo {
    public static void main(String[] args) {
        Subject subject = new Subject();

        Observer obs1 = new ConcreteObserver("Observer 1");
        Observer obs2 = new ConcreteObserver("Observer 2");

        subject.registerObserver(obs1);
        subject.registerObserver(obs2);

        subject.setState("State Changed");
    }
}</code></pre>
</section>

<footer>
  <b>&copy; 2025 RKTechGame | All rights reserved</b>
</footer>
</body>
</html>
